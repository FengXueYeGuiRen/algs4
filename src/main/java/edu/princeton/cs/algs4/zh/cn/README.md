###### 算法（第4版）

当前(目录)章节|节|章||
---|---|---|---|
第4章 图(329)||||
4.1 无向图(331)| |第4章 图(329)||
4.1.1 术语表(331)|4.1 无向图(331)|第4章 图(329)||
4.1.2 表示无向图的数据类型(333)|4.1 无向图(331)|第4章 图(329)|[AdjacencyListsGraph.java(邻接表无向图)](graph/undirected/AdjacencyListsGraph.java)|
4.1.3 深度优先搜索(338)|4.1 无向图(331)|第4章 图(329)|[DepthFirstSearch.java](graph/DepthFirstSearch.java)|
4.1.4 寻找路径(342)|4.1 无向图(331)|第4章 图(329)|[DephFirstPaths.java(算法 4.1)](graph/DephFirstPaths.java)|
4.1.5 广度优先搜索(344)|4.1 无向图(331)|第4章 图(329)||
4.1.6 连通分量(349)|4.1 无向图(331)|第4章 图(329)||
4.1.7 符号图(352)|4.1 无向图(331)|第4章 图(329)||
4.1.8 总结(358)|4.1 无向图(331)|第4章 图(329)||
4.2 有向图(364)| |第4章 图(329)||
4.2.1 术语(364)|4.2 有向图(364)|第4章 图(329)||
4.2.2 有向图的数据类型(365)|4.2 有向图(364)|第4章 图(329)||
4.2.3 有向图中的可达性(367)|4.2 有向图(364)|第4章 图(329)||
4.2.4 环和有向无环图(369)|4.2 有向图(364)|第4章 图(329)||
4.2.5 有向图中的强连通性(378)|4.2 有向图(364)|第4章 图(329)||
4.2.6 总结(385)|4.2 有向图(364)|第4章 图(329)||
4.3 最小生成树(390)| |第4章 图(329)||
4.3.1 原理(391)|4.3 最小生成树(390)|第4章 图(329)||
4.3.2 加权无向图的数据类型(393)|4.3 最小生成树(390)|第4章 图(329)||
4.3.3 最小生成树的API和测试用例(396)|4.3 最小生成树(390)|第4章 图(329)||
4.3.4 Prim算法(398)|4.3 最小生成树(390)|第4章 图(329)||
4.3.5 Prim算法的即时实现(401)|4.3 最小生成树(390)|第4章 图(329)||
4.3.6 Kruskal算法(404)|4.3 最小生成树(390)|第4章 图(329)||
4.3.7 展望(407)|4.3 最小生成树(390)|第4章 图(329)||
4.4 最短路径(412)| |第4章 图(329)||
4.4.1 最短路径的性质(413)|4.4 最短路径(412)|第4章 图(329)||
4.4.2 加权有向图的数据结构(414)|4.4 最短路径(412)|第4章 图(329)||
4.4.3 最短路径算法的理论基础(420)|4.4 最短路径(412)|第4章 图(329)||
4.4.4 Dijkstra算法(421)|4.4 最短路径(412)|第4章 图(329)||
4.4.5 无环加权有向图中的最短路径算法(425)|4.4 最短路径(412)|第4章 图(329)||
4.4.6 一般加权有向图中的最短路径问题(433)|4.4 最短路径(412)|第4章 图(329)||
4.4.7 展望(445)|4.4 最短路径(412)|第4章 图(329)||
第2章 排序(152)||||
2.1 初级排序算法(153)| |第2章 排序(152)||
2.1.1 游戏规则(153)|2.1 初级排序算法|第2章 排序|[Example.java](sorting/Example.java)|
2.1.2 选择排序(155)|2.1 初级排序算法|第2章 排序|[SelectionSort.java(算法 2.1)](sorting/SelectionSort.java)|
2.1.3 插入排序(157)|2.1 初级排序算法|第2章 排序|[InsertionSort.java(算法 2.2)](sorting/InsertionSort.java)|
2.1.4 排序算法的可视化(159)|2.1 初级排序算法|第2章 排序|[StdDraw.java](./../StdDraw.java)|
2.1.5 比较两种排序算法(159)|2.1 初级排序算法|第2章 排序|[SortCompare.java](sorting/SortCompare.java)|
2.1.6 希尔排序(162)|2.1 初级排序算法|第2章 排序|[ShellInsertionSort.java(算法 2.3)](sorting/ShellInsertionSort.java)|
2.2 归并排序(170)| |第2章 排序(152)||
2.2.1 原地归并的抽象方法(170)|2.2 归并排序|第2章 排序||
2.2.2 自顶向下的归并排序(171)|2.2 归并排序|第2章 排序|[MergeSort.java(算法 2.4)](sorting/MergeSort.java)|
2.2.3 自底向上的归并排序(175)|2.2 归并排序|第2章 排序|[MergeBUSort.java](sorting/MergeBUSort.java)|
2.2.4 排序算法的复杂度(177)|2.2 归并排序|第2章 排序||
2.3 快速排序(182)| |第2章 排序(152)||
2.3.1 基本算法(182)|2.3 快速排序|第2章 排序|[QuickSort.java(算法 2.5)](sorting/QuickSort.java)|
2.3.2 性能特点(185)|2.3 快速排序|第2章 排序||
2.3.3 算法改进(187)|2.3 快速排序|第2章 排序||
2.4 优先队列(195)| |第2章 排序(152)||
2.4.1 API(195)|2.4 优先队列|第2章 排序||
2.4.2 初级实现(197)|2.4 优先队列|第2章 排序||
2.4.3 堆的定义(198)|2.4 优先队列|第2章 排序||
2.4.4 堆的算法(199)|2.4 优先队列|第2章 排序|[BinaryHeapMaxPQ.java(算法 2.6)](sorting/pq/QuickSort.java)|
2.4.5 堆排序(205)|2.4 优先队列|第2章 排序|[HeapSort.java(算法 2.7)](sorting/HeapSort.java)|
2.5 应用(214)| |第2章 排序(152)||
2.5.1 将各种数据排序(214)|2.5 应用|第2章 排序||
2.5.2 我应该使用哪种排序算法(218)|2.5 应用|第2章 排序||
2.5.3 问题的归约(219)|2.5 应用|第2章 排序||
2.5.4 排序应用一览(221)|2.5 应用|第2章 排序||
第3章 查找(227)||||
3.1 符号表(228)| |第3章 查找(227)|
3.1.1 API(228)|3.1 符号表(228)|第3章 查找(227)||
3.1.2 有序符号表(230)|3.1 符号表(228)|第3章 查找(227)||
3.1.3 用例举例(233)|3.1 符号表(228)|第3章 查找(227)||
3.1.4 无序链表中的顺序查找(235)|3.1 符号表(228)|第3章 查找(227)||
3.1.5 有序数组中的二分查找(238)|3.1 符号表(228)|第3章 查找(227)|[BinarySearchSymbolTable.java(算法 3.2)](searching/BinarySearchSymbolTable.java)|
3.1.6 对二分查找的分析(242)|3.1 符号表(228)|第3章 查找(227)|
3.1.7 预览(244)|3.1 符号表(228)|第3章 查找(227)|
3.2 二叉查找树(250)| |第3章 查找(227)|[BinarySearchTree.java(算法 3.3)](searching/BinarySearchTree.java)|
3.2.1 基本实现(250)|3.2 二叉查找树(250)|第3章 查找(227)||
3.2.2 分析(255)|3.2 二叉查找树(250)|第3章 查找(227)|
3.2.3 有序性相关的方法与删除操作(257)|3.2 二叉查找树(250)|第3章 查找(227)||
3.3 平衡查找树(269)| |第3章 查找(227)||
3.3.1 2-3查找树(269)|3.3 平衡查找树(269)|第3章 查找(227)||
3.3.2 红黑二叉查找树(275)|3.3 平衡查找树(269)|第3章 查找(227)||
3.3.3 实现(280)|3.3 平衡查找树(269)|第3章 查找(227)||
3.3.4 删除操作(282)|3.3 平衡查找树(269)|第3章 查找(227)||
3.3.5 红黑树的性质(284)|3.3 平衡查找树(269)|第3章 查找(227)||
3.4 散列表(293)| |第3章 查找(227)||
3.4.1 散列函数(293)|3.4 散列表(293)|第3章 查找(227)||
3.4.2 基于拉链法的散列表(297)|3.4 散列表(293)|第3章 查找(227)|[SeparateChainingHashSymbolTable.java(算法 3.5)](searching/SeparateChainingHashSymbolTable.java)|
3.4.3 基于线性探测法的散列表(300)|3.4 散列表(293)|第3章 查找(227)|[LinearProbingHashSymbolTable.java(算法 3.6)](searching/LinearProbingHashSymbolTable.java)|
3.4.4 调整数组大小(304)|3.4 散列表(293)|第3章 查找(227)||
3.4.5 内存使用(306)|3.4 散列表(293)|第3章 查找(227)||
3.5 应用(312)| |第3章 查找(227)||
3.5.1 我应该使用符号表的哪种实现(312)|3.5 应用(312)|第3章 查找(227)||
3.5.2 集合的API(313)|3.5 应用(312)|第3章 查找(227)||
3.5.3 字典类用例(315)|3.5 应用(312)|第3章 查找(227)||
3.5.4 索引类用例(318)|3.5 应用(312)|第3章 查找(227)||
3.5.5 稀疏向量(322)|3.5 应用(312)|第3章 查找(227)||

